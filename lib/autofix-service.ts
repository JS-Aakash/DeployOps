import fs from 'fs';
import path from 'path';
import os from 'os';
import { execSync } from 'child_process';
import OpenAI from 'openai';
import { Octokit } from '@octokit/rest';

// Prompts
const FIX_PROMPT_TEMPLATE = `You are an expert software engineer fixing a GitHub issue.

## ISSUE

{{ISSUE_BODY}}

## CURRENT CODEBASE

{{CODEBASE}}

## YOUR TASK

Analyze the issue and generate a fix. You MUST respond with valid JSON only.

## RULES

1. Output COMPLETE file contents (not diffs)
2. Only include files that need changes
3. Generate tests ONLY if they can be run with simple Node.js assert
4. Use Node.js assert for tests (no jest/mocha unless project uses them)
5. Match existing code style

## WHEN TO GENERATE TESTS

‚úÖ **Generate tests for**:
- Backend functions (pure functions, utilities, APIs)
- Node.js modules that can run standalone
- Simple logic that doesn't need external dependencies
- Files that already have test files in the repo

‚ùå **DO NOT generate tests for**:
- Frontend code (HTML, CSS, browser JavaScript)
- Code that requires a database
- Code that requires external APIs
- Code that needs a browser or DOM
- Complex integration scenarios
- If no test framework exists in the repo

## OUTPUT FORMAT

Respond with ONLY valid JSON in this exact format:

\`\`\`json
{
  "files": [
    {
      "path": "index.js",
      "content": "function add(a, b) {\\n    return a + b;\\n}\\n\\nmodule.exports = { add };"
    },
    {
      "path": "test.js",
      "content": "const assert = require('assert');\\nconst { add } = require('./index');\\n\\ntry {\\n    assert.strictEqual(add(2, 3), 5);\\n    console.log('‚úÖ test passed');\\n} catch (e) {\\n    console.error('‚ùå test failed:', e.message);\\n    process.exit(1);\\n}"
    }
  ]
}
\`\`\`

## IMPORTANT

- Use REAL filenames from the codebase (index.js, test.js, app.js, etc.)
- NO placeholders (path/to/file.ext, example.js)
- Include \\n for newlines in content
- Escape quotes properly in JSON
- Output ONLY the JSON, no explanations
- If you can't test it, don't create a test file

## TEST FILE REQUIREMENTS (Only if applicable)

For test files:
- Use \`const assert = require('assert');\`
- Test normal cases and edge cases
- Use try-catch with process.exit(1) on failure
- Log success with console.log('‚úÖ test passed')
- Log failures with console.error('‚ùå test failed:', e.message)
`;

const PR_BODY_TEMPLATE = `### AI Auto-Fix
**Issue**: {{ISSUE_BODY}}

**Changes**:
- Automated fix generated by AI Agent.

**Verification**:
- Tests passed Successfully.

---
@coderabbitai review
`;

interface RunOptions {
    issueUrl: string;
    repoUrl: string;
    githubToken: string;
    openaiKey: string;
    onLog: (msg: string, level?: 'info' | 'error' | 'success' | 'warning') => void;
}

export async function runAutofix(opts: RunOptions) {
    const { issueUrl, repoUrl, githubToken, openaiKey, onLog } = opts;
    const log = (msg: string, level: 'info' | 'error' | 'success' | 'warning' = 'info') => {
        onLog(msg, level);
    };

    const workspaceDir = fs.mkdtempSync(path.join(os.tmpdir(), 'autofix-'));
    log(`Using workspace: ${workspaceDir}`, 'info');

    try {
        // Helper to run commands
        const runCmd = (cmd: string, cwd: string = workspaceDir, ignoreError = false) => {
            // Pre-flight check for git
            if (cmd.startsWith('git')) {
                try {
                    execSync('git --version', { stdio: 'ignore' });
                } catch (e) {
                    // Check if we are potentially on Vercel
                    if (process.env.VERCEL) {
                        throw new Error("Git is not found in the path. Vercel Serverless Functions do not include 'git' by default. This agent requires a specialized runtime or container.");
                    }
                    throw new Error("Git is not installed or not in the system path.");
                }
            }

            log(`$ ${cmd}`, 'info');
            const startTime = Date.now();
            try {
                const stdout = execSync(cmd, { cwd, stdio: 'pipe', encoding: 'utf-8' });
                const duration = Date.now() - startTime;
                log(`Command completed in ${duration}ms`, 'info');
                if (stdout && stdout.trim()) {
                    log(`Output: ${stdout.trim().substring(0, 200)}${stdout.length > 200 ? '...' : ''}`, 'info');
                }
            } catch (e: any) {
                const duration = Date.now() - startTime;
                const stderr = e.stderr ? e.stderr.toString() : e.message;
                if (!ignoreError) {
                    throw new Error(`Command failed after ${duration}ms: ${cmd}\nError: ${stderr}`);
                }
                log(`Command warning: ${stderr}`, 'warning');
            }
        };

        // 1. Fetch Issue
        log('‚¨áÔ∏è Fetching issue details...', 'info');
        const issueData = await fetchIssue(issueUrl, githubToken);
        log(`‚úÖ Found Issue #${issueData.number}: ${issueData.title}`, 'success');

        // 2. Clone Repo
        log('‚¨áÔ∏è Cloning repository...', 'info');
        // Construct auth URL
        const repoMatch = repoUrl.match(/github\.com\/(.+?)\/(.+?)(\.git)?$/);
        if (!repoMatch) throw new Error("Invalid GitHub URL");
        const [_, owner, repoName] = repoMatch;
        const authRepoUrl = `https://${githubToken}@github.com/${owner}/${repoName}.git`;

        runCmd(`git clone "${authRepoUrl}" .`); // Clone into workspace root

        // 3. Create Branch
        const branchName = `fix/issue-${issueData.number}-ai-${Date.now()}`;
        log(`üåø Creating branch ${branchName}...`, 'info');
        runCmd(`git checkout -b ${branchName}`);

        // Set user config for commit
        runCmd(`git config user.email "bot@autofix.ai"`);
        runCmd(`git config user.name "AutoFix AI Bot"`);

        // 4. Analyze Codebase
        log('Reading codebase...', 'info');
        const files = readCodebase(workspaceDir);
        const codebaseContext = files.map(f => `File: ${f.path}\nContent:\n${f.content}\n`).join('\n---\n');

        // 5. Build Prompt & Call AI
        log('ü§ñ Calling AI Agent...', 'info');
        const prompt = FIX_PROMPT_TEMPLATE
            .replace('{{ISSUE_BODY}}', issueData.body)
            .replace('{{CODEBASE}}', codebaseContext);

        const aiResponse = await callAI(prompt, openaiKey, (msg) => log(msg, 'info'));

        if (!aiResponse || !aiResponse.files || aiResponse.files.length === 0) {
            throw new Error("AI returned no files to change.");
        }

        log(`‚úÖ AI generated changes for ${aiResponse.files.length} files.`, 'success');

        // 6. Apply Changes
        log('üîß Applying changes...', 'info');

        for (const file of aiResponse.files) {
            const filePath = path.join(workspaceDir, file.path);
            const dir = path.dirname(filePath);
            if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

            fs.writeFileSync(filePath, file.content);
            log(`Updated ${file.path}`, 'info');
        }

        // 7. Run Tests (Best Effort)
        // Check if package.json exists
        if (fs.existsSync(path.join(workspaceDir, 'package.json'))) {
            log('üß™ Detected Node.js project. Installing dependencies...', 'info');
            try {
                // Try lightweight install first
                runCmd('npm install --ignore-scripts --no-audit --no-fund', workspaceDir);

                log('üß™ Running tests...', 'info');
                runCmd('npm test', workspaceDir);
                log('‚úÖ Tests passed!', 'success');
            } catch (e: any) {
                log('‚ö†Ô∏è Tests failed or dependencies failed to install. Proceeding anyway (MVP mode).', 'warning');
            }
        }

        // 8. Commit & Push
        // 8. Commit & Push
        log('‚¨ÜÔ∏è Pushing changes...', 'info');
        runCmd('git add .');

        try {
            const status = execSync('git status --porcelain', { cwd: workspaceDir, encoding: 'utf-8' });
            if (!status || status.trim().length === 0) {
                throw new Error("AI generated code matches existing code. No changes to commit.");
            }
        } catch (e: any) {
            // If it's our error, rethrow. If execSync failed, let it be (unlikely for status)
            if (e.message.includes("No changes")) throw e;
            log(`‚ö†Ô∏è Git status check failed: ${e.message}`, 'warning');
        }

        runCmd(`git commit -m "fix: resolve issue #${issueData.number} (AI Auto-fix)"`);
        try {
            runCmd(`git push origin ${branchName}`);
        } catch (e: any) {
            const errHash = e.message || "";
            if (errHash.includes("403") || errHash.includes("Permission denied")) {
                throw new Error(`Git Push Failed (403 Forbidden). \nPossible causes:\n1. The GitHub token being used (session or .env) does not have 'repo' (write) scope.\n2. You are using a Fine-grained Token without 'Contents: Write' access.\n3. The token has expired or is invalid.`);
            }
            throw e;
        }

        // 9. Create PR
        log('üìù Creating Pull Request...', 'info');
        const prUrl = await createPR({
            owner,
            repo: repoName,
            branch: branchName,
            issueNumber: issueData.number,
            issueBody: issueData.body,
            token: githubToken
        });

        log(`üéâ PR Created: ${prUrl}`, 'success');
        return { status: 'SUCCESS', prUrl };

    } catch (e: any) {
        log(`‚ùå Error: ${e.message}`, 'error');
        throw e;
    } finally {
        // Cleanup
        try {
            fs.rmSync(workspaceDir, { recursive: true, force: true });
        } catch (e) { /* ignore */ }
    }
}

// --- Helpers ---

async function fetchIssue(url: string, token: string) {
    // If it's an internal monitoring URL
    if (url.includes('internal/monitoring/issues/')) {
        const id = url.split('issues/')[1];
        const { Issue } = await import('@/models');
        await (await import('@/lib/mongodb')).default();
        const issue = await Issue.findById(id);
        if (!issue) throw new Error("Internal Issue not found");
        return {
            number: 0,
            title: issue.title,
            body: issue.description || '',
        };
    }

    const parts = url.split('github.com/')[1].split('/');
    const owner = parts[0];
    const repo = parts[1];
    const number = parseInt(parts[3]);

    const octokit = new Octokit({ auth: token });
    const { data } = await octokit.issues.get({ owner, repo, issue_number: number });
    return {
        number: data.number,
        title: data.title,
        body: data.body || '',
    };
}

async function createPR(opts: { owner: string, repo: string, branch: string, issueNumber: number, issueBody: string, token: string }) {
    const octokit = new Octokit({ auth: opts.token });
    const body = PR_BODY_TEMPLATE.replace('{{ISSUE_BODY}}', opts.issueBody);

    const { data } = await octokit.pulls.create({
        owner: opts.owner,
        repo: opts.repo,
        title: `fix: resolve issue #${opts.issueNumber}`,
        head: opts.branch,
        base: 'main', // Assuming main
        body: body
    });
    return data.html_url;
}

function readCodebase(dir: string, fileList: { path: string, content: string }[] = [], rootDir = dir) {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);

        if (file === '.git' || file === 'node_modules' || file === 'package-lock.json') continue;

        if (stat.isDirectory()) {
            readCodebase(filePath, fileList, rootDir);
        } else {
            if (['.js', '.ts', '.md', '.json', '.html', '.css', '.txt'].includes(path.extname(file))) {
                const content = fs.readFileSync(filePath, 'utf8');
                // simple max size check
                if (content.length < 50000) {
                    fileList.push({
                        path: path.relative(rootDir, filePath),
                        content: content
                    });
                }
            }
        }
    }
    return fileList;
}

async function callAI(prompt: string, apiKey: string, onLog?: (msg: string) => void) {
    const finalKey = apiKey || process.env.API_KEY;
    if (!finalKey) throw new Error("No API Key provided (client or server API_KEY).");

    const isOpenRouter = finalKey.startsWith('sk-or-');
    const isCerebras = finalKey.startsWith('csk-');
    const isTogether = finalKey.startsWith('together_');
    const isGroq = finalKey.startsWith('gsk_');
    const isOllama = finalKey.startsWith('ollama:');

    let baseURL = undefined;
    if (isOpenRouter) baseURL = 'https://openrouter.ai/api/v1';
    else if (isCerebras) baseURL = 'https://api.cerebras.ai/v1';
    else if (isTogether) baseURL = 'https://api.together.xyz/v1';
    else if (isGroq) baseURL = 'https://api.groq.com/openai/v1';
    else if (isOllama) baseURL = 'http://localhost:11434/v1';

    const openai = new OpenAI({
        apiKey: isOllama ? 'ollama' : finalKey,
        baseURL
    });

    let modelName = 'gpt-4o';
    if (isOpenRouter) modelName = 'google/gemini-2.0-flash-exp:free';
    else if (isCerebras) modelName = 'llama3.1-8b';
    else if (isTogether) modelName = 'meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo';
    else if (isGroq) modelName = 'llama3-70b-8192';
    else if (isOllama) modelName = finalKey.split(':')[1] || 'llama3';

    if (onLog) onLog(`Sending request to ${baseURL || 'OpenAI'} with model ${modelName}...`);
    const startTime = Date.now();

    const completion = await openai.chat.completions.create({
        messages: [{ role: 'user', content: prompt }],
        model: modelName,
        response_format: { type: "json_object" },
        max_tokens: 4000,
        temperature: 0.2,
    });

    if (onLog) onLog(`AI response received in ${Date.now() - startTime}ms.`);

    const content = completion.choices[0].message.content;
    if (!content) return null;
    return JSON.parse(content);
}
